/**
 * QuantilyxDoc - Professional Document Editor
 * Copyright (C) 2025 RÂ² Innovative Software
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */
#ifndef QUANTILYX_MALWARESCANNER_H
#define QUANTILYX_MALWARESCANNER_H

#include <QObject>
#include <QList>
#include <QFuture>
#include <memory>

namespace QuantilyxDoc {

class Document; // Forward declaration

/**
 * @brief Enum describing the result of a malware scan.
 */
enum class ScanResult {
    Clean,      // No threats found
    Infected,   // Threats found
    Suspicious, // Potentially suspicious content found, unsure
    Error,      // An error occurred during the scan
    Scanning,   // Scan is in progress (used internally)
    Unknown     // Result could not be determined
};

/**
 * @brief Structure holding information about a potential threat found during scanning.
 */
struct ThreatInfo {
    QString name;         // Name of the threat (e.g., "EICAR-TEST-NOT-A-VIRUS")
    QString type;         // Type of threat (e.g., "Virus", "Trojan", "Malicious Macro", "Suspicious JS")
    QString description;  // Description of the threat
    QString action;       // Recommended action (e.g., "Quarantine", "Delete", "Allow", "Investigate")
    int severity;         // Severity level (e.g., 1-5, or enum)
    QString filePath;     // Path to the file containing the threat (if applicable)
    QString embeddedPath; // Path within the document if it's an embedded object (e.g., "EmbeddedFile1.bin")
    qint64 fileSize;      // Size of the suspicious part (if applicable)
    QString sha256Hash;   // Hash of the suspicious part (if applicable)
};

/**
 * @brief Scans documents for potential malware, viruses, trojans, and other threats.
 * 
 * Interfaces with external antivirus engines or heuristic analysis tools/libraries.
 * Can scan the entire document file or specific embedded objects/pages if the format supports it.
 */
class MalwareScanner : public QObject
{
    Q_OBJECT

public:
    /**
     * @brief Constructor.
     * @param parent Parent object.
     */
    explicit MalwareScanner(QObject* parent = nullptr);

    /**
     * @brief Destructor.
     */
    ~MalwareScanner() override;

    /**
     * @brief Get singleton instance.
     * @return Reference to the global MalwareScanner instance.
     */
    static MalwareScanner& instance();

    /**
     * @brief Scan a document file for malware.
     * @param filePath Path to the document file.
     * @return The overall ScanResult.
     */
    ScanResult scanFile(const QString& filePath) const;

    /**
     * @brief Scan a document file for malware and get detailed threat information.
     * @param filePath Path to the document file.
     * @return Pair of overall ScanResult and list of ThreatInfo objects found.
     */
    QPair<ScanResult, QList<ThreatInfo>> scanFileDetailed(const QString& filePath) const;

    /**
     * @brief Scan a loaded Document object for malware.
     * This might involve extracting embedded objects/pages and scanning them individually.
     * @param document The loaded document object.
     * @return Pair of overall ScanResult and list of ThreatInfo objects found.
     */
    QPair<ScanResult, QList<ThreatInfo>> scanDocument(Document* document) const;

    /**
     * @brief Scan a document file for malware asynchronously.
     * @param filePath Path to the document file.
     * @return A QFuture that will hold the scan result pair upon completion.
     */
    QFuture<QPair<ScanResult, QList<ThreatInfo>>> scanFileAsync(const QString& filePath) const;

    /**
     * @brief Scan a specific embedded file within a document.
     * @param document The parent document.
     * @param embeddedFilePath Path of the embedded file within the document structure.
     * @return Pair of ScanResult and ThreatInfo list for the embedded file.
     */
    QPair<ScanResult, QList<ThreatInfo>> scanEmbeddedFile(Document* document, const QString& embeddedFilePath) const;

    /**
     * @brief Get the list of supported file formats (extensions) for scanning.
     * @return List of supported extensions (e.g., "pdf", "epub", "docx", "zip").
     */
    QStringList supportedFormats() const;

    /**
     * @brief Set the path to the external antivirus scanner executable (e.g., clamscan, mcafee, symantec).
     * @param path Scanner executable path.
     */
    void setScannerExecutablePath(const QString& path);

    /**
     * @brief Get the path to the external antivirus scanner executable.
     * @return Scanner executable path string.
     */
    QString scannerExecutablePath() const;

    /**
     * @brief Set the path to the configuration file for the external scanner (if applicable).
     * @param path Config file path.
     */
    void setScannerConfigPath(const QString& path);

    /**
     * @brief Get the path to the configuration file for the external scanner.
     * @return Config file path string.
     */
    QString scannerConfigPath() const;

    /**
     * @brief Enable or disable heuristic analysis (if supported by the scanner engine).
     * @param enabled Whether to enable heuristic analysis.
     */
    void setHeuristicAnalysisEnabled(bool enabled);

    /**
     * @brief Check if heuristic analysis is enabled.
     * @return True if enabled.
     */
    bool isHeuristicAnalysisEnabled() const;

    /**
     * @brief Enable or disable scanning of embedded objects within documents.
     * @param enabled Whether to scan embedded objects.
     */
    void setEmbeddedScanningEnabled(bool enabled);

    /**
     * @brief Check if scanning of embedded objects is enabled.
     * @return True if enabled.
     */
    bool isEmbeddedScanningEnabled() const;

    /**
     * @brief Enable or disable scanning of script content within documents (e.g., JavaScript in PDFs).
     * @param enabled Whether to scan scripts.
     */
    void setScriptScanningEnabled(bool enabled);

    /**
     * @brief Check if scanning of script content is enabled.
     * @return True if enabled.
     */
    bool isScriptScanningEnabled() const;

    /**
     * @brief Get the last error message encountered during a scan.
     * @return Error message string.
     */
    QString lastErrorMessage() const;

    /**
     * @brief Get the last exit code from the external scanner process (if applicable).
     * @return Exit code integer.
     */
    int lastScannerExitCode() const;

signals:
    /**
     * @brief Emitted when a scan starts.
     * @param filePath Path to the file being scanned.
     */
    void scanStarted(const QString& filePath);

    /**
     * @brief Emitted when a scan finishes successfully.
     * @param filePath Path to the scanned file.
     * @param result The overall scan result.
     * @param threats List of threats found (if any).
     */
    void scanFinished(const QString& filePath, QuantilyxDoc::ScanResult result, const QList<QuantilyxDoc::ThreatInfo>& threats);

    /**
     * @brief Emitted when a scan fails.
     * @param filePath Path to the file that failed scanning.
     * @param error Error message.
     */
    void scanFailed(const QString& filePath, const QString& error);

    /**
     * @brief Emitted periodically during a long-running scan task.
     * @param progress Progress percentage (0-100).
     */
    void scanProgress(int progress);

    /**
     * @brief Emitted when a potential threat is detected during a scan.
     * @param threat The ThreatInfo structure describing the threat.
     */
    void threatDetected(const QuantilyxDoc::ThreatInfo& threat);

private:
    class Private;
    std::unique_ptr<Private> d;

    // Helper to map external scanner output/status codes to our ScanResult enum
    ScanResult mapExternalResult(int exitCode, const QString& output) const;
};

} // namespace QuantilyxDoc

#endif // QUANTILYX_MALWARESCANNER_H