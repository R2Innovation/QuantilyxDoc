/**
 * QuantilyxDoc - Professional Document Editor
 * Copyright (C) 2025 RÂ² Innovative Software
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */
#include "MalwareScanner.h"
#include "../core/Document.h"
#include "../core/Logger.h"
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QStandardPaths>
#include <QMutex>
#include <QMutexLocker>
#include <QFuture>
#include <QtConcurrent/QtConcurrent>
#include <QProcess>
#include <QRegularExpression>
#include <QDebug>

namespace QuantilyxDoc {

class MalwareScanner::Private {
public:
    Private(MalwareScanner* q_ptr)
        : q(q_ptr), heuristicEnabled(false), embeddedEnabled(true), scriptEnabled(false) {} // Default settings

    MalwareScanner* q;
    mutable QMutex mutex; // Protect access if concurrent scanning is needed
    QString scannerExecutablePathStr;
    QString scannerConfigPathStr;
    bool heuristicEnabled;
    bool embeddedEnabled;
    bool scriptEnabled;
    QString lastErrorMsg;
    int lastExitCode = -1;

    // Helper to run an external scanner process (e.g., clamav's clamscan, mcafee, symantec command line tools)
    QPair<ScanResult, QList<ThreatInfo>> runExternalScanner(const QString& filePath) const {
        if (scannerExecutablePathStr.isEmpty()) {
            LOG_ERROR("MalwareScanner::runExternalScanner: No scanner executable path set.");
            lastErrorMsg = "Scanner executable path is not configured.";
            return qMakePair(ScanResult::Error, QList<ThreatInfo>());
        }

        QFileInfo fileInfo(filePath);
        if (!fileInfo.exists()) {
            LOG_ERROR("MalwareScanner::runExternalScanner: File does not exist: " << filePath);
            lastErrorMsg = "File does not exist.";
            return qMakePair(ScanResult::Error, QList<ThreatInfo>());
        }

        QStringList args;
        // Add common arguments for most scanners: verbosity, config file, file path
        if (!scannerConfigPathStr.isEmpty()) {
            // This argument varies by scanner. Example for ClamAV: --config-file=
            // args << "--config-file=" + scannerConfigPathStr;
            LOG_WARN("MalwareScanner::runExternalScanner: Config file argument not standardized. Scanner: " << scannerExecutablePathStr);
            // For now, assume scanner reads config from default location or ignore config path for this stub.
        }
        // Example args for ClamAV: --stdout --infected <file_path>
        // Example args for generic: -v <file_path>
        args << "--stdout"; // Many CL scanners support this for output redirection
        args << "--infected"; // ClamAV specific, indicates only infected files reported to stdout
        args << filePath;

        QProcess scannerProcess;
        LOG_DEBUG("MalwareScanner::runExternalScanner: Executing: " << scannerExecutablePathStr << " " << args.join(" "));
        scannerProcess.start(scannerExecutablePathStr, args);
        bool finished = scannerProcess.waitForFinished(-1); // Wait indefinitely for scan to complete

        if (!finished) {
            lastErrorMsg = "Scanner process did not finish.";
            LOG_ERROR("MalwareScanner::runExternalScanner: " << lastErrorMsg);
            return qMakePair(ScanResult::Error, QList<ThreatInfo>());
        }

        lastExitCode = scannerProcess.exitCode();
        QString output = scannerProcess.readAllStandardOutput();
        QString errorOutput = scannerProcess.readAllStandardError();

        LOG_DEBUG("MalwareScanner::runExternalScanner: Scanner exit code: " << lastExitCode);
        LOG_DEBUG("MalwareScanner::runExternalScanner: Scanner output: " << output);
        if (!errorOutput.isEmpty()) {
            LOG_DEBUG("MalwareScanner::runExternalScanner: Scanner stderr: " << errorOutput);
        }

        // Parse output based on scanner's format.
        // Example for ClamAV: "filename: EICAR-Test-Signature FOUND"
        QPair<ScanResult, QList<ThreatInfo>> result;
        result.first = ScanResult::Clean; // Assume clean initially
        if (lastExitCode == 0) {
            // Exit code 0 often means clean, but check output anyway (some scanners behave differently)
            if (output.contains("FOUND", Qt::CaseInsensitive) || output.contains("INFECTED", Qt::CaseInsensitive)) {
                 // Even if exit code is 0, some scanners put "FOUND" in output if --infected was used but no threats were found.
                 // The logic depends on the specific scanner's output format and exit codes.
                 // For ClamAV with --infected, exit code 1 means infection found.
                 if (lastExitCode == 1) {
                     result.first = ScanResult::Infected;
                     // Parse threats from output
                     QRegularExpression threatRegex(R"((.+):\s+(.+) FOUND)");
                     QRegularExpressionMatchIterator iter = threatRegex.globalMatch(output);
                     while (iter.hasNext()) {
                         QRegularExpressionMatch match = iter.next();
                         QString fileName = match.captured(1);
                         QString threatName = match.captured(2);
                         ThreatInfo threat;
                         threat.name = threatName;
                         threat.type = "Virus"; // Default type, could be parsed differently
                         threat.description = "Detected by external scanner: " + threatName;
                         threat.action = "Quarantine"; // Default action
                         threat.severity = 5; // Default high severity
                         threat.filePath = fileName;
                         result.second.append(threat);
                     }
                 } else {
                     // Exit code 0, no "FOUND" with --infected means clean
                     result.first = ScanResult::Clean;
                 }
            } else {
                result.first = ScanResult::Clean;
            }
        } else if (lastExitCode == 1) {
            // For ClamAV, exit code 1 means virus found
            result.first = ScanResult::Infected;
            QRegularExpression threatRegex(R"((.+):\s+(.+) FOUND)");
            QRegularExpressionMatchIterator iter = threatRegex.globalMatch(output);
            while (iter.hasNext()) {
                QRegularExpressionMatch match = iter.next();
                QString fileName = match.captured(1);
                QString threatName = match.captured(2);
                ThreatInfo threat;
                threat.name = threatName;
                threat.type = "Virus";
                threat.description = "Detected by external scanner: " + threatName;
                threat.action = "Quarantine";
                threat.severity = 5;
                threat.filePath = fileName;
                result.second.append(threat);
            }
        } else {
            // Other exit codes might indicate errors, timeouts, etc.
            result.first = ScanResult::Error;
            lastErrorMsg = QString("Scanner returned error code %1. Stderr: %2").arg(lastExitCode).arg(errorOutput);
        }

        if (result.first == ScanResult::Error) {
            LOG_ERROR("MalwareScanner::runExternalScanner: Scanner error: " << lastErrorMsg);
        } else if (result.first == ScanResult::Infected) {
            LOG_WARN("MalwareScanner::runExternalScanner: Threats found in " << filePath << ": " << result.second.size());
        } else {
            LOG_INFO("MalwareScanner::runExternalScanner: File is clean: " << filePath);
        }

        return result;
    }
};

// Static instance pointer
MalwareScanner* MalwareScanner::s_instance = nullptr;

MalwareScanner& MalwareScanner::instance()
{
    if (!s_instance) {
        s_instance = new MalwareScanner();
    }
    return *s_instance;
}

MalwareScanner::MalwareScanner(QObject* parent)
    : QObject(parent)
    , d(new Private(this))
{
    LOG_INFO("MalwareScanner created.");
}

MalwareScanner::~MalwareScanner()
{
    LOG_INFO("MalwareScanner destroyed.");
}

QPair<MalwareScanner::ScanResult, QList<MalwareScanner::ThreatInfo>> MalwareScanner::scanFile(const QString& filePath) const
{
    LOG_INFO("MalwareScanner: Starting scan for file: " << filePath);
    emit scanStarted(filePath);

    QPair<ScanResult, QList<ThreatInfo>> result = d->runExternalScanner(filePath);

    if (result.first == ScanResult::Clean) {
        emit scanFinished(filePath, result.first, result.second);
    } else if (result.first == ScanResult::Infected) {
        emit scanFinished(filePath, result.first, result.second);
        // Potentially emit threatDetected for each threat in result.second
        for (const auto& threat : result.second) {
            emit threatDetected(threat);
        }
    } else { // Error
        emit scanFailed(filePath, d->lastErrorMsg);
    }

    LOG_INFO("MalwareScanner: Finished scan for file: " << filePath << ", Result: " << static_cast<int>(result.first) << ", Threats found: " << result.second.size());
    return result;
}

QPair<MalwareScanner::ScanResult, QList<MalwareScanner::ThreatInfo>> MalwareScanner::scanFileDetailed(const QString& filePath) const
{
    // This could potentially perform more in-depth analysis (heuristics, embedded file extraction/scanning)
    // For now, it just calls the standard scanFile.
    // Heuristic scanning would require analyzing the file content structure (e.g., PE headers, script content) directly.
    // Scanning embedded objects would require the Document class to extract them and pass them to scanFile().
    LOG_DEBUG("MalwareScanner::scanFileDetailed: Performing standard scan for " << filePath);
    if (d->heuristicEnabled || d->embeddedEnabled || d->scriptEnabled) {
        LOG_WARN("MalwareScanner::scanFileDetailed: Heuristic/Embedded/Script scanning options are enabled but not implemented beyond external scanner call.");
        // Future: Implement logic here to:
        // 1. Load document using DocumentFactory
        // 2. Extract embedded files if d->embeddedEnabled
        // 3. Scan embedded files recursively
        // 4. Analyze script content if d->scriptEnabled (e.g., JavaScript in PDF)
        // 5. Perform basic heuristic checks on file structure if d->heuristicEnabled
    }
    return scanFile(filePath);
}

QPair<MalwareScanner::ScanResult, QList<MalwareScanner::ThreatInfo>> MalwareScanner::scanDocument(Document* document) const
{
    if (!document) {
        LOG_ERROR("MalwareScanner::scanDocument: Null document provided.");
        emit scanFailed("unknown", "Null document provided for scanning.");
        return qMakePair(ScanResult::Error, QList<ThreatInfo>());
    }

    QString filePath = document->filePath();
    if (filePath.isEmpty()) {
        LOG_ERROR("MalwareScanner::scanDocument: Document has no file path.");
        emit scanFailed("unknown", "Document has no associated file path for scanning.");
        return qMakePair(ScanResult::Error, QList<ThreatInfo>());
    }

    LOG_INFO("MalwareScanner: Starting scan for loaded document: " << filePath);
    emit scanStarted(filePath);

    // Perform the main file scan
    QPair<ScanResult, QList<ThreatInfo>> overallResult = d->runExternalScanner(filePath);

    // If enabled, scan embedded objects within the document
    if (d->embeddedEnabled && overallResult.first != ScanResult::Error) {
        LOG_DEBUG("MalwareScanner::scanDocument: Scanning embedded objects for " << filePath);
        // QList<QString> embeddedFilePaths = document->extractEmbeddedObjectsToTemp(); // Hypothetical method
        // for (const QString& embeddedPath : embeddedFilePaths) {
        //     auto embeddedResult = scanFile(embeddedPath); // Recursive scan call
        //     // Merge results: if any embedded object is infected, mark overall as infected
        //     if (embeddedResult.first == ScanResult::Infected) {
        //         overallResult.first = ScanResult::Infected;
        //         overallResult.second.append(embeddedResult.second); // Add threats found in embedded objects
        //     }
        //     // Clean up temp file
        //     QFile::remove(embeddedPath);
        // }
        LOG_WARN("MalwareScanner::scanDocument: Scanning embedded objects requires Document::extractEmbeddedObjectsToTemp method.");
    }

    // If enabled, scan script content within the document
    if (d->scriptEnabled && overallResult.first != ScanResult::Error) {
        LOG_DEBUG("MalwareScanner::scanDocument: Scanning script content for " << filePath);
        // QString scriptContent = document->getAllScriptContent(); // Hypothetical method
        // if (!scriptContent.isEmpty()) {
        //     // Pass scriptContent to a script analysis engine or sandbox
        //     // For now, just log a warning if any script is found.
        //     if (scriptContent.contains("eval\\(|document\\.write|unescape|fromCharCode", Qt::CaseInsensitive)) {
        //         ThreatInfo scriptThreat;
        //         scriptThreat.name = "Potential Malicious Script";
        //         scriptThreat.type = "Script";
        //         scriptThreat.description = "Document contains potentially dangerous script patterns.";
        //         scriptThreat.action = "Review";
        //         scriptThreat.severity = 3; // Medium
        //         scriptThreat.filePath = filePath;
        //         overallResult.second.append(scriptThreat);
        //         overallResult.first = ScanResult::Suspicious; // Or Infected if rule is strict enough
        //     }
        // }
        LOG_WARN("MalwareScanner::scanDocument: Scanning script content requires Document::getAllScriptContent method.");
    }

    if (overallResult.first == ScanResult::Clean) {
        emit scanFinished(filePath, overallResult.first, overallResult.second);
    } else if (overallResult.first == ScanResult::Infected || overallResult.first == ScanResult::Suspicious) {
        emit scanFinished(filePath, overallResult.first, overallResult.second);
        for (const auto& threat : overallResult.second) {
            emit threatDetected(threat);
        }
    } else { // Error
        emit scanFailed(filePath, d->lastErrorMsg);
    }

    LOG_INFO("MalwareScanner: Finished scan for document: " << filePath << ", Result: " << static_cast<int>(overallResult.first) << ", Threats found: " << overallResult.second.size());
    return overallResult;
}

QFuture<QPair<MalwareScanner::ScanResult, QList<MalwareScanner::ThreatInfo>>> MalwareScanner::scanFileAsync(const QString& filePath) const
{
    // Use QtConcurrent to run the scan in a separate thread
    return QtConcurrent::run(&MalwareScanner::scanFile, this, filePath);
}

QPair<MalwareScanner::ScanResult, QList<MalwareScanner::ThreatInfo>> MalwareScanner::scanEmbeddedFile(Document* document, const QString& embeddedFilePath) const
{
    if (!document) {
        LOG_ERROR("MalwareScanner::scanEmbeddedFile: Null document provided.");
        return qMakePair(ScanResult::Error, QList<ThreatInfo>());
    }

    // This would involve extracting the embedded file to a temporary location and scanning it.
    // QString tempPath = document->extractEmbeddedObject(embeddedFilePath); // Hypothetical method
    // if (!tempPath.isEmpty()) {
    //     auto result = scanFile(tempPath);
    //     QFile::remove(tempPath); // Clean up temp file
    //     return result;
    // }
    LOG_WARN("MalwareScanner::scanEmbeddedFile: Requires Document::extractEmbeddedObject method.");
    return qMakePair(ScanResult::Unknown, QList<ThreatInfo>()); // Placeholder
}

QStringList MalwareScanner::supportedFormats() const
{
    // The scanner itself might not care about format, but the integration with DocumentFactory does.
    // Supported formats are those supported by DocumentFactory + potentially raw file types supported by the external scanner.
    // For the external scanner, it often depends on the scanner itself (ClamAV supports many types, including archives).
    return QStringList() << "pdf" << "epub" << "djvu" << "cbz" << "cbr" << "ps" << "xps" << "chm" << "md" << "fb2" << "mobi" << "odt" << "docx" << "zip" << "tar" << "gz" << "bz2" << "exe" << "dll"; // Add more based on external scanner's capabilities
}

void MalwareScanner::setScannerExecutablePath(const QString& path)
{
    QMutexLocker locker(&d->mutex);
    if (d->scannerExecutablePathStr != path) {
        d->scannerExecutablePathStr = path;
        LOG_INFO("MalwareScanner: External scanner executable path set to: " << path);
    }
}

QString MalwareScanner::scannerExecutablePath() const
{
    QMutexLocker locker(&d->mutex);
    return d->scannerExecutablePathStr;
}

void MalwareScanner::setScannerConfigPath(const QString& path)
{
    QMutexLocker locker(&d->mutex);
    if (d->scannerConfigPathStr != path) {
        d->scannerConfigPathStr = path;
        LOG_INFO("MalwareScanner: External scanner config path set to: " << path);
    }
}

QString MalwareScanner::scannerConfigPath() const
{
    QMutexLocker locker(&d->mutex);
    return d->scannerConfigPathStr;
}

void MalwareScanner::setHeuristicAnalysisEnabled(bool enabled)
{
    QMutexLocker locker(&d->mutex);
    if (d->heuristicEnabled != enabled) {
        d->heuristicEnabled = enabled;
        LOG_INFO("MalwareScanner: Heuristic analysis enabled: " << enabled);
    }
}

bool MalwareScanner::isHeuristicAnalysisEnabled() const
{
    QMutexLocker locker(&d->mutex);
    return d->heuristicEnabled;
}

void MalwareScanner::setEmbeddedScanningEnabled(bool enabled)
{
    QMutexLocker locker(&d->mutex);
    if (d->embeddedEnabled != enabled) {
        d->embeddedEnabled = enabled;
        LOG_INFO("MalwareScanner: Embedded object scanning enabled: " << enabled);
    }
}

bool MalwareScanner::isEmbeddedScanningEnabled() const
{
    QMutexLocker locker(&d->mutex);
    return d->embeddedEnabled;
}

void MalwareScanner::setScriptScanningEnabled(bool enabled)
{
    QMutexLocker locker(&d->mutex);
    if (d->scriptEnabled != enabled) {
        d->scriptEnabled = enabled;
        LOG_INFO("MalwareScanner: Script content scanning enabled: " << enabled);
    }
}

bool MalwareScanner::isScriptScanningEnabled() const
{
    QMutexLocker locker(&d->mutex);
    return d->scriptEnabled;
}

QString MalwareScanner::lastErrorMessage() const
{
    QMutexLocker locker(&d->mutex);
    return d->lastErrorMsg;
}

int MalwareScanner::lastScannerExitCode() const
{
    QMutexLocker locker(&d->mutex);
    return d->lastExitCode;
}

} // namespace QuantilyxDoc